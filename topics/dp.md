# 动态规划

## 1 解题步骤

Dynamic Programming 动态规划

真正理解 DP 应该注意一下几点：

1. DP 数组中每一个值，或者索引的意义
2. 递推公式
3. DP 数组的如何初始化
4. 遍历顺序
5. 打印 DP 数组（主要用于分析错误）

### 1.1 什么时候用

1. 判断所有可能的状态中（图）是不是有环，有环一定不是 DP
2. 数据量极大的情况下不太能用 DP

DP 的核心是，递推关系要固定不变，能找到让关系保持不变的 dp 数组定义，这点也是最难的

### 1.2 入门递推相关题目

- 0070 - 爬楼梯 ｜ [LeetCode 链接](https://leetcode.cn/problems/climbing-stairs/) ｜ [题解笔记](../solutions/0001-0100/0070-climbing-stairs.md)
- 0096 - 不同的二叉搜索树 ｜ [LeetCode 链接](https://leetcode.cn/problems/unique-binary-search-trees/) ｜ [题解笔记](../solutions/0001-0100/0096-unique-binary-search-trees.md)
- 0337 - 打家劫舍 III ｜ [LeetCode 链接](https://leetcode.cn/problems/house-robber-iii/) ｜ [题解笔记](../solutions/0301-0400/0337-house-robber-iii.md)

## 2 背包问题

### 2.1 零一背包 （二维数组）

>给定 n 件物品，每件物品有价值 `value[i]` 和重量 `weight[i]`
>在容量为 W 的背包中选择若干件物品，使得总价值最大，每件物品最多选一次。

先用没有空间简化的方式进行分析（二维 dp）

1. 数组的定义：`[0, i]` 个物品，任选放入容量为 `j` 背包中的最大价值为 `dp[i][j]`
2. 递推公式：

 - 不放物品 `i` 则和 `i - 1` 一致
 - 如果放入 `dp[i - 1][j - weight[i]] + value[i]`，也就是不放入之前的最大价值（注意要改重量）+ 放入后的最大价值
 - 取上述两种情况的最大值，就是递推公式
 - 记得需要检查 `j - weight[i]] + value[i]`是否成立，也就是当前容量是否能够放入这个物品

3. 初始化需要先分析递推公式需要的前置条件

 - 需要的是 `[i - 1][j]` 或者 `[i - 1][j - n]` 的数据，因此初始化横纵坐标即可
 - 其他位置初始化，实际上这个值和后面的求值没有关系，初始化为任何值都可以
 - 其实初始化还可以横纵坐标都用 0 作为边界条件，不过代码随想录里并没有这么做

4. 遍历顺序，根据递推公式前置条件可以得到，实际上二维 dp 是没有顺序要求的，正序倒序以及背包物品顺序都可以颠倒

```C++
// 假设：dp 的维度是 dp[N][C+1]，并且已初始化为 0
// dp[i][j]：用前 i 个物品（下标 0..i），在容量 j 下的最大价值

for (int j = 0; j <= C; j++) {
    if (j >= w[0]) dp[0][j] = v[0];
    // else dp[0][j] = 0;  // 已初始化可省略
}

for (int i = 1; i < N; i++) {
    for (int j = 0; j <= C; j++) {
        dp[i][j] = dp[i-1][j];  // 不选第 i 个，先继承
        if (j >= w[i]) {
            dp[i][j] = max(dp[i][j], dp[i-1][j - w[i]] + v[i]);  // 选第 i 个
        }
    }
}
```

### 2.2 零一背包（滚动数组）

可以发现一个问题，就是 `dp[i]` 一直使用的是 `dp[i - 1]` 相关的数据进行计算的

但是要注意遍历的顺序，检查递推公式：`dp[i - 1][j - weight[i]] + value[i]` 和 `dp[i - 1][j]` 其中之一，可以发现`j` 依赖于 上一轮次的 `j` 或者 `j - weight[i]`，这两个都是小于等于 `j` 的，因此 dp[j] 的遍历要用到上一轮的更小值，应该是**从大到小**遍历才可以！

1. 数组定义：在第 `i` 次循环中`dp[j]` 容量为 `j` 的背包的最大价值
2. 递推公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])` （注意其实 i 这个索引还是存在的，只是把 ` p` 数组压缩一个维度）
3. 初始化：`dp[0]`肯定是 0，其他数值初始化为可能的数值中的最小值（为了防止覆盖其他值），看题目，一般也是 0
4. 遍历顺序：先遍历物品数量，再遍历背包容量，第二层循环需要倒序（因为不可以对依赖项进行覆写）

代码部分可以参考本文中 *分割等和子集* 题目

```c++
// w 和 v 下标从 0 开始
for (int i = 0; i < N; i++) {
    for (int j = C; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

### 2.3 完全背包

> 每一个物品可以使用无数次的背包

对于二维的情况下，直接改成就是完全背包，表示允许重复选取某一个数

```c++
dp[i][j] = max(
    dp[i-1][j],                 // 不选第 i 个物品
    dp[i][j - w[i]] + v[i]      // 选第 i 个物品（可重复）
)
```

把内层 for 循环改成正序遍历就可以让物品使用无限次

```c++
for (int i = 0; i < N; ++i) {
    for (int j = w[i]; j <= C; ++j) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

这里要明确清楚为什么，因为在正序遍历的时候 `dp[j - w[i]] + v[i]`这个数值中的 `dp[j - w[i]]` 是在本轮（外层 i 循环）之前遍历的，有可能是已经添加过物品 i 的一个状态。这时候的递推是基于本轮的状态实现的，可以在此基础上再添加一个物品 i，因此就构成了每个物品可以无限取用的情况，也就是完全背包

另外要注意一点：**纯**完全背包的遍历顺序（物品和背包）是**可以颠倒**的！

原因就是一个：递推公式中可以由前面的数值推出当前的数值，我的建议是如果理解的话还是需要手动模拟一下横纵的顺序，就可以发现颠倒顺序后仍然可以用前面的状态推出当前的状态

```c++
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

### 2.4 完全背包的排列组合

但是如果涉及到了排列组合问题，就会导致遍历顺序需要注意

假设我们的物品重量为 `w[] = [1, 2, 3];`，对于取物品恰好满足和为 target 的题目，递推公式为`dp[j] += dp[j - w[i]];`

这个递推公式是通用的，关键在于 `dp[j - w[i]]`代表的数值是什么

对于 **先遍历物品后遍历背包**的场景（01 背包通用方式）：

1. 在 1 物品选择依次放满所有的背包
2. 在 12 物品中选择依次放满，这个情况下只会有**先 1 后 2**的放入情况

意思是放入 2 以后，必定只会放入 >= 2 的物品，不会再回去放入 1，这种情况是**组合**

对于 **先遍历背包后遍历物品**的场景：

我认为这个有点抽象，所以这里用了手写的方式来解释

这里 dp 数组中是一个个确认过去的，内层循环中会反复对同一个 `dp[j]` 进行状态的累加，因此参考下图可以发现重叠的问题

就是因为取物品的顺序不是固定的，`i` 的循环表示最后补上这个物品（没有圈的数值），但这就会导致每个物品都有可能为那个“补充值”，但是补充值本身会在 `0 + j`的情况下被计算一次：

举例来说：3 = 1 + 2， 这里的 2 当做“补充值”，表示在所有和为 1 的情况上末尾补充一个 2 可以达成和为 3，但是当我们求补充值为 1 的时候，计算所有和为 2 的情况个数的时候，会和补充值为 2 的情况重复

<img src="http://oss.rainerseventeen.cn/blog/2025/202512021823120.jpeg" alt="完全背包排列数" style="zoom: 33%;" />

### 2.5 背包相关题目

- 0416 - 分割等和子集 ｜ [LeetCode 链接](https://leetcode.cn/problems/partition-equal-subset-sum/) ｜ [题解笔记](../solutions/0401-0500/0416-partition-equal-subset-sum.md)
- 0494 - 目标和 ｜ [LeetCode 链接](https://leetcode.cn/problems/target-sum/) ｜ [题解笔记](../solutions/0401-0500/0494-target-sum.md)
- 0279 - 完全平方数 ｜ [LeetCode 链接](https://leetcode.cn/problems/perfect-squares/) ｜ [题解笔记](../solutions/0201-0300/0279-perfect-squares.md)

## 3 股票问题

股票问题的关键仍然在于 dp 数组的定义

定义 `dp[i][0]` 和 `dp[i][1]` 分别表示股票的持有和未持有，而不是统计买入与卖出，这是唯一的关键

### 3.1 股票相关题目

- 0121 - 买卖股票的最佳时机 ｜ [LeetCode 链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) ｜ [题解笔记](../solutions/0101-0200/0121-best-time-to-buy-and-sell-stock.md)

## 4 子序列问题

> 如果是连续子序列问题，可以查看 KMP 算法

如果是两个字符串相关的比较，将连个字符串构成一个 二维的数组可罗列所有的状态

一般来说永远推荐把 `dp[j]`定义为 `nums[j - 1]`为结尾的 xxx 状态，这样可以省去一个初始化特判的过程

之后的 for 循环只需要从 1 遍历到 `nums.size() + 1`即可

### 4.1 LCS 最长子序列

最长子序列问题：考虑删除这唯一一个操作

删除表示不在某一个字符串中考虑这个字符，也就是在对应的 dp 数组中向上回退一个数字

不同的题目需要注意删除这个操作对 dp 数组内容的影响

### 4.2 编辑距离

编辑距离就是 删除操作会导致一个操作数 + 1

编辑距离的另一个主要特点就是： 操作是相互的，也就是删除 a 的一个元素，等价于给 b 增加一个元素

另外，如果替换一个字符，等于消耗一个操作，将两个字符变成相等

因此总结来看，终究还是删除和相等两种操作，关键在于需要学会定义 dp 数组为 `nums[i - 1]` 对应的 xxx

### 4.3 回文串

回文串的特点是他的状态转移不是取决于某一个值的加入，而是第一个值和最后一个值的加入

意思是状态转移时设定 `dp[i][j]` 代表 `[i, j)` 的字符串是不是回文串的时候，其依赖的状态是 `dp[i + 1][j - 1]`

### 4.4 子序列相关题目

- 0300 - 最长递增子序列 ｜ [LeetCode 链接](https://leetcode.cn/problems/longest-increasing-subsequence/) ｜ [题解笔记](../solutions/0201-0300/0300-longest-increasing-subsequence.md)
- 0718 - 最长重复子数组 ｜ [LeetCode 链接](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/) ｜ [题解笔记](../solutions/0701-0800/0718-maximum-length-of-repeated-subarray.md)
- 0072 - 编辑距离 ｜ [LeetCode 链接](https://leetcode.cn/problems/edit-distance/) ｜ [题解笔记](../solutions/0001-0100/0072-edit-distance.md)
- 0516 - 最长回文子序列 ｜ [LeetCode 链接](https://leetcode.cn/problems/longest-palindromic-subsequence/) ｜ [题解笔记](../solutions/0501-0600/0516-longest-palindromic-subsequence.md)

## 5 补充专题

### 5.1 单词拆分类题（抽象）

这类题可以抽象为“字符串容量 + 字典词物品”的可达性 DP：

- `dp[i]` 表示前 `i` 个字符是否可被字典拆分。
- 枚举词长或枚举字典词，检查 `dp[i - len]` 与子串匹配关系。
- 重点是定义“状态表示前缀可达”，而不是纠结每次切分位置。

字符串比较时，`s.compare(pos, len, target) == 0` 表示子串相等。

## 6 总结

这类题目的难点在于是不是能够合理的猜想出一个可行的 dp 数组定义，这很依赖经验

另外，如果有了一个 dp 数组定义的想法了，我的建议是写一个 **一般一点的例子** 来列出整个 dp 数组

我的意思是，相比于对着逻辑进行直接推到状态转移的关系，有时候瞪眼法看看数组找规律也许很有效（也就是猜一个转移过程来证明一下，对于复杂一点的题目可能会好写一点）
