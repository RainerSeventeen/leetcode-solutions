# 动态规划

## 1 概览

Dynamic Programming 动态规划

这是一种重要的算法思想，核心思想是通过定义恰当的状态来实现状态转移，从而解决优化问题。

## 2 核心思想

真正理解 DP 应该注意以下几点：

1. DP 数组中每一个值，或者索引的意义
2. 递推公式
3. DP 数组的如何初始化
4. 遍历顺序
5. 打印 DP 数组（主要用于分析错误）

DP 的核心是，递推关系要固定不变，能找到让关系保持不变的 dp 数组定义，这点也是最难的。

## 3 解题流程

### 3.1 什么时候用 DP

1. 判断所有可能的状态中（图）是不是有环，有环一定不是 DP
2. 数据量极大的情况下不太能用 DP

### 3.2 解题流程

1. 定义 dp 数组及其含义
2. 根据定义确定递推公式
3. 初始化 dp 数组（根据递推公式的前置条件）
4. 确定遍历顺序
5. 测试与验证

## 4 模板与子方法

### 4.1 入门：基础递推

这是最简单的 DP 问题，直接按照定义进行递推即可。

**方法说明**：通过定义 `dp[i]` 代表某个状态，然后通过简单的递推公式计算后续状态。

**模板代码**：

```c++
// 最基础的 DP 模板
dp[0] = base_case;
for (int i = 1; i <= n; i++) {
    dp[i] = dp[i-1] + ...;  // 根据前一个状态推导
}
```

**模板题目**：

- 0070 - 爬楼梯 ｜ [LeetCode 链接](https://leetcode.cn/problems/climbing-stairs/) ｜ [题解笔记](../solutions/0001-0100/0070-climbing-stairs.md)
- 0096 - 不同的二叉搜索树 ｜ [LeetCode 链接](https://leetcode.cn/problems/unique-binary-search-trees/) ｜ [题解笔记](../solutions/0001-0100/0096-unique-binary-search-trees.md)
- 0337 - 打家劫舍 III ｜ [LeetCode 链接](https://leetcode.cn/problems/house-robber-iii/) ｜ [题解笔记](../solutions/0301-0400/0337-house-robber-iii.md)

### 4.2 背包问题

背包问题是 DP 中的经典问题。关键在于定义 `dp[i][j]` 为在特定容量下的最优值，然后根据是否选择当前物品来转移状态。

#### 4.2.1 子方法 A：零一背包（二维数组）

**问题描述**：给定 n 件物品，每件物品有价值 `value[i]` 和重量 `weight[i]`。在容量为 W 的背包中选择若干件物品，使得总价值最大，每件物品最多选一次。

**方法说明**：先用未经空间简化的方式进行分析，使用二维 dp 数组。

1. 数组定义：`dp[i][j]` 表示用前 i 个物品，在容量 j 下的最大价值
2. 递推公式：
   - 不选物品 i：`dp[i-1][j]`
   - 选物品 i：`dp[i-1][j-weight[i]] + value[i]`（需要检查容量充足）
   - 取两者最大值
3. 初始化：根据递推公式前置条件初始化边界
4. 遍历顺序：二维 dp 没有顺序要求，正序倒序都可以

**模板代码**：

```C++
// dp[i][j]：用前 i 个物品，在容量 j 下的最大价值
for (int j = 0; j <= C; j++) {
    if (j >= w[0]) dp[0][j] = v[0];
}

for (int i = 1; i < N; i++) {
    for (int j = 0; j <= C; j++) {
        dp[i][j] = dp[i-1][j];  // 不选第 i 个
        if (j >= w[i]) {
            dp[i][j] = max(dp[i][j], dp[i-1][j - w[i]] + v[i]);  // 选第 i 个
        }
    }
}
```

**模板题目**：

- 0416 - 分割等和子集 ｜ [LeetCode 链接](https://leetcode.cn/problems/partition-equal-subset-sum/) ｜ [题解笔记](../solutions/0401-0500/0416-partition-equal-subset-sum.md)

#### 4.2.2 子方法 B：零一背包（滚动数组优化）

**方法说明**：在零一背包的基础上，利用递推只依赖前一行的特性，将二维数组压缩为一维。

**关键点**：因为递推依赖于 `j` 和 `j - weight[i]` 两个位置（都小于等于当前 j），所以必须倒序遍历背包容量，避免覆盖尚需使用的旧值。

1. 数组定义：`dp[j]` 表示容量 j 的背包的最大价值
2. 递推公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
3. 初始化：`dp[0] = 0`，其他值根据题目初始化
4. 遍历顺序：先物品后背包，**背包容量倒序**

**模板代码**：

```c++
// w 和 v 下标从 0 开始，倒序遍历背包容量
for (int i = 0; i < N; i++) {
    for (int j = C; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

**模板题目**：

- 0494 - 目标和 ｜ [LeetCode 链接](https://leetcode.cn/problems/target-sum/) ｜ [题解笔记](../solutions/0401-0500/0494-target-sum.md)

#### 4.2.3 子方法 C：完全背包

**问题描述**：每一个物品可以使用无数次的背包问题。

**方法说明**：与零一背包的区别在于递推公式和遍历顺序。完全背包允许多次选择同一物品。

在二维情况下的递推：
```c++
dp[i][j] = max(
    dp[i-1][j],                 // 不选第 i 个物品
    dp[i][j - w[i]] + v[i]      // 选第 i 个物品（可重复）
)
```

关键区别：第二项依赖的是同一行的 `dp[i][j - w[i]]`，而非上一行，这允许多次使用同一物品。

1. 遍历顺序：内层循环改为正序遍历，因为 `dp[j - w[i]]` 可能已包含物品 i 的状态
2. 特殊性质：纯完全背包的物品和背包遍历顺序可以颠倒

**模板代码**：

```c++
// 标准完全背包（先物品后背包，背包正序）
for (int i = 0; i < N; ++i) {
    for (int j = w[i]; j <= C; ++j) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}

// 颠倒遍历顺序也可以（先背包后物品）
for(int j = 0; j <= bagWeight; j++) {
    for(int i = 0; i < weight.size(); i++) {
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

**模板题目**：

- 0279 - 完全平方数 ｜ [LeetCode 链接](https://leetcode.cn/problems/perfect-squares/) ｜ [题解笔记](../solutions/0201-0300/0279-perfect-squares.md)

#### 4.2.4 子方法 D：完全背包的排列组合问题

**方法说明**：当背包问题涉及排列数或组合数时，遍历顺序的含义会改变。

对于求和为 target 的方案数，递推公式为 `dp[j] += dp[j - w[i]]`。关键在于理解 `dp[j - w[i]]` 代表的是什么：

- **先物品后背包**（背包正序）：只会产生组合（不考虑顺序）
  - 物品 1 用于所有容量，再物品 2 用于所有容量
  - 确保先选小编号物品，避免重复

- **先背包后物品**（背包正序）：会产生排列（考虑顺序）
  - 每个容量反复与所有物品配对
  - 允许任意顺序选择，产生排列数

**示例说明**：对于 `w = [1, 2, 3]` 和 target = 3
- 组合：只有 `{1+2}` 一种（不重复计数 `{2+1}`)
- 排列：有 `{1+2}` 和 `{2+1}` 两种（考虑顺序）

**模板题目**：

此方法的具体应用需在组合和排列问题中体现，根据题意选择合适的遍历顺序。

### 4.3 股票问题

**方法说明**：股票问题的关键在于 dp 数组的定义。定义 `dp[i][0]` 和 `dp[i][1]` 分别表示股票的持有和未持有状态，而不是统计买入与卖出次数，这是解题的唯一关键。

**核心思想**：
- `dp[i][0]`：第 i 天持有股票的最大利润
- `dp[i][1]`：第 i 天未持有股票的最大利润
- 递推时只需考虑前一天的两种状态即可推导当前状态

**模板题目**：

- 0121 - 买卖股票的最佳时机 ｜ [LeetCode 链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) ｜ [题解笔记](../solutions/0101-0200/0121-best-time-to-buy-and-sell-stock.md)

### 4.4 子序列问题

**前置知识**：连续子序列问题可参考 KMP 算法。

**通用建议**：
- 对于两个序列的比较问题，构造二维 dp 数组可以罗列所有状态组合
- 推荐定义 `dp[i]` 为以 `nums[i-1]` 为结尾的相关状态，可省去初始化特判
- For 循环从 1 遍历到 `nums.size() + 1`

#### 4.4.1 子方法 A：LCS 最长公共子序列

**方法说明**：最长子序列问题的核心操作是"删除"。删除表示不在某一个字符串中考虑这个字符，对应 dp 数组向上回退一个数字。

**递推思想**：
- `dp[i][j]` 表示两个序列前 i/j 个字符的最长公共子序列长度
- 若字符相等：`dp[i][j] = dp[i-1][j-1] + 1`
- 若字符不等：`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（删除其中一个字符继续匹配）

不同题目需注意删除操作对 dp 含义的影响。

**模板题目**：

- 0300 - 最长递增子序列 ｜ [LeetCode 链接](https://leetcode.cn/problems/longest-increasing-subsequence/) ｜ [题解笔记](../solutions/0201-0300/0300-longest-increasing-subsequence.md)
- 0718 - 最长重复子数组 ｜ [LeetCode 链接](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/) ｜ [题解笔记](../solutions/0701-0800/0718-maximum-length-of-repeated-subarray.md)

#### 4.4.2 子方法 B：编辑距离

**方法说明**：编辑距离计算两个序列转换所需的最少操作次数。删除操作导致操作数 + 1，替换字符也消耗一个操作。

**关键性质**：编辑操作是相互的，删除序列 A 的一个元素等价于给序列 B 增加一个元素。

**递推思想**：
- `dp[i][j]` 表示前 i 和 j 个字符的编辑距离
- 字符相等：`dp[i][j] = dp[i-1][j-1]`（无需操作）
- 字符不等：`dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`
  - `dp[i-1][j] + 1`：删除 A[i]
  - `dp[i][j-1] + 1`：插入 A[i]（等价于删除 B[j]）
  - `dp[i-1][j-1] + 1`：替换

核心在于定义 dp 含义为 `[i-1]` 和 `[j-1]` 对应的状态。

**模板题目**：

- 0072 - 编辑距离 ｜ [LeetCode 链接](https://leetcode.cn/problems/edit-distance/) ｜ [题解笔记](../solutions/0001-0100/0072-edit-distance.md)

#### 4.4.3 子方法 C：回文子序列

**方法说明**：回文串问题的状态转移不是取决于某一个值的加入，而是两端字符的加入。

**递推特点**：
- `dp[i][j]` 代表子串 `[i, j]` 的相关状态（如是否回文、最长回文长度等）
- 依赖的状态是 `dp[i+1][j-1]`（两端各向内缩一格）
- 需要考虑两端字符的关系而非顺序

这种从两端向中心的递推方式是回文问题的特殊之处。

**模板题目**：

- 0516 - 最长回文子序列 ｜ [LeetCode 链接](https://leetcode.cn/problems/longest-palindromic-subsequence/) ｜ [题解笔记](../solutions/0501-0600/0516-longest-palindromic-subsequence.md)

### 4.5 单词拆分问题

**方法说明**：这类题可以抽象为”字符串容量 + 字典词物品”的可达性 DP。

**核心思想**：
- `dp[i]` 表示前 i 个字符是否可被字典拆分（或其他状态）
- 枚举词长或枚举字典中的词，检查 `dp[i - len]` 与子串的匹配关系
- 重点是定义”状态表示前缀可达性”，而不是纠结每次的具体切分位置

**字符串匹配技巧**：
- `s.compare(pos, len, target) == 0`：检查从位置 pos 开始长度为 len 的子串是否等于 target
- 或使用 `s.substr(pos, len) == target` 进行子串比较

## 5 易错点

1. **dp 数组定义不清晰**：在开始编码前，必须明确定义每个 dp 值代表的具体含义
2. **初始化不完整**：初始化必须满足递推公式的前置条件，否则递推会出错
3. **遍历顺序错误**：
   - 零一背包一维优化时必须倒序遍历容量
   - 完全背包一维优化时必须正序遍历容量
   - 涉及排列组合时要特别注意遍历物品和容量的顺序
4. **状态依赖关系混淆**：理解递推公式依赖哪些前置状态，确定遍历顺序
5. **边界条件处理**：特别要检查数组越界和初始值的设置

## 6 总结

动态规划问题的难点在于能否定义出合理的 dp 数组。这依赖经验积累和问题理解。

**解题建议**：
1. 定义 dp 数组的含义
2. 根据定义推导递推公式
3. 确定初始化条件
4. 写出遍历顺序
5. **最重要**：写一个具体的小规模例子，手工列出整个 dp 数组来验证逻辑

这种”瞪眼法”（直观观察数组找规律）有时比直接推导状态转移更有效，对于复杂问题尤为有用。
