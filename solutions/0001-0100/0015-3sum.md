---
id: 15
title: 3Sum
difficulty: Medium
tags: [array, two-pointers, sorting]
created: 2026-02-20
---

# 15. 三数之和

## 题目链接
https://leetcode.cn/problems/3sum/

## 题目描述
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>

<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]
<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]
<strong>解释：</strong>
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,1,1]
<strong>输出：</strong>[]
<strong>解释：</strong>唯一可能的三元组和不为 0 。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [0,0,0]
<strong>输出：</strong>[[0,0,0]]
<strong>解释：</strong>唯一可能的三元组和为 0 。
</pre>

<p><strong>提示：</strong></p>

<ul>
	<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
	<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
</ul>


## 解题思路

排序 + 枚举一个数 + 双指针找两数之和。

- 先对数组排序；
- 枚举下标 `i` 作为第一个数，目标变为在区间 `(i, n)` 内找 `nums[l] + nums[r] = -nums[i]`；
- 用 `l=i+1, r=n-1` 双指针：和小则 `l++`，和大则 `r--`，相等则记录答案并跳过重复值。

去重要点：

- `i` 与前一个值相同则跳过；
- 找到一组解后，分别移动 `l/r` 跳过所有与当前相同的值，避免重复三元组。

剪枝：若 `nums[i] > 0`，由于数组已排序，后面不可能再凑出 0，可直接结束枚举。

复杂度主要由外层枚举 + 内层双指针扫描决定；额外空间为常数级（不计排序实现的栈空间与输出）。

- 时间复杂度: $O(n^2)$
- 空间复杂度: $O(1)$

## 相关专题
- [滑动窗口与双指针](../../topics/sliding-window-and-two-pointers.md)

## 代码
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        ret = []
        for i in range(n - 2):
            if nums[i] > 0:
                continue
            if i != 0 and nums[i - 1] == nums[i]: # 重复值去重
                continue
            target = -nums[i]
            l = i + 1
            r = n - 1
            while l < r:
                curr = nums[l] + nums[r]
                if curr < target:
                    l += 1
                elif curr > target:
                    r -= 1
                else:
                    ret.append([nums[i], nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l - 1]: # 重复值去重
                        l += 1
                    while l < r and nums[r] == nums[r + 1]: # 重复值去重
                        r -= 1
        return ret
```
